# 공통

## 노드와 자바의 차이

## 멀티브라우징을 지원하기 위해서 어떻게 했는가?

## sass같은 전처리기 스타일링은 해봤는지?

## sass같은 css 전처리기의 이점이 있다면?

## git전략에 대해 생각해본적 있는지?

- flow나 그 외의 다양한 전략
- 소스트리라는 GUI 도구

## 크로스 브라우징을 구현하기 위해 HTML에서 어떤 작업을 해줘야할지?

## 웹팩같은 번들러를 쓰는 이유가 뭐라고 생각하나?

## 프론트엔드에서 신경써야할 보안이 있다면 뭐가 있을까?

## script태그를 body하단에 넣는 이유가 뭔가? 이런 문제를 해결하기 위해선?

body의 최하단이 가장 좋다.  
dom parsing을 방해하지 않기 때문이다.  
물론 script태그의 속성이나 onload이벤트를 이용해서 스크립트 로드시점과 실행시점을 바꿀 수 있다.

- defer와 asyn 속성에 대한 차이 추가.

## 브라우저 렌더링과정에 대해서 설명해봐라

통신을 통해 문서의 내용을 받아 온뒤
HTML 문서를 파싱하여 DOM tree를 만들고 병렬적으로 CSS 요소를 파싱하여 CSSOM를 만든다.  
Dom과 CSSOM를 기반으로 렌더트리를 생성한다. 이때 화면에 불필요한 노드들은 렌더트리에서 빠집니다.  
 각 노드가 화면의 정확한 위치에 표시되도록 레이아웃을 계산하고
UI백엔드에서 렌더 트리의 각 노드를 그린다. 이 작업은 병렬적으로 이루어지는데 모든 HTML을 파싱하면서 배치와 페인트과정이 동시에 일어납니다.

1. DOM 생성
2. CSSOM (CSS Object Model) 생성
3. Render Tree 생성
4. Layout: Render Tree 배치
5. Rendering: Render Tree 그리기 이러한 과정을 통해 브라우저가 서버에 요청한 내용의 노드들을 픽셀화 시키는 것을 브라우저 렌더링 이라고 한다.

## 프로세스와 쓰레드의 차이는 무엇인지?

프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고 스레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위입니다.  
프로세스는 실행될 때 운영체제로부터 프로세서, 필요한 주소 공간, 메모리 등 자원을 할당받습니다. 스레드란 한 프로세스 내에서 동작되는 여러 실행의 흐름으로 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내에 스레드끼리 공유하면서 실행됩니다.

**질문의도**

- 운영체제에서 작업을 실행할 때 자원을 할당하는 단위를 알고 있느냐와 프로그램을 멀티 스레드를 구현할 때 장.단점
- 프로세스와 스레드에 대한 질문은 결국에는 운영체제가 시스템의 자원을 어떤 단위로 할당하고, 프로세스와 스레드는 이 자원을 어떻게 사용하느냐를 알고 있냐에 대한 질문입니다.

  **멀티스레딩을 하는 이유**  
  운영체제는 시스템 자원을 효율적으로 관리하기 위해서 스레드를 사용하는 것이죠.  
  즉 멀티스레딩을 하는 이유는 자원 재활용때문입니다.

1. 자원 재활용

- 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 새로운 프로세스를 생성하기 위한 메모리를 절약할 수 있습니다.
- (프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어든다.)

2. 통신비용 절감

- 프로세스 간의 통신보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어들게 됩니다.

**멀티 스레딩의 단점**

1. 동기화문제

- 스레드를 활용하면 자원의 효율성이 증가하기도 하지만 스레드 간의 자원 공유는 전역 변수를 이용하므로 동기화 문제에 신경을 써야 합니다.

## CORS(Cross-Origin Resource Sharing)는 무엇인가 왜 이러한 방법이 정의 되었으며, 본인이 코드를 작성하면서 CORS와 관련하여서 경험하였던 이슈는 무엇인가

1. CORS란?

- 웹 브라우저에서 크로스 도메인 서버와 통신하기 위한 방식을 표준화한 스펙
- 서버와 클라이언트가 정해진 헤더를 통해 서로 요청이나 응답에 반응할지 결정하는 방식
- 요청 받은 웹서버가 허용할 경우에 다른 도메인에서 자원을 주고받을 수 있게 해준다.

2. 관련 경험이 있느냐?  
   리액트를 이용한 미세먼지 조회 서비스를 만들 때, 공공기관에서 미세먼지 정보를 받아오는 오픈 API를 사용했습니다.  
   먼저 postMan이라는 API 테스트 도구를 이용했을 때 문제가 없었는데 브라우저에서 요청을 보내니 CORS오류가 났다.  
   알고보니 API 키 발급시 등록했던 클라이언트 도메인과 포트가 생긴 문제 였다.
   이때 크로스 도메인 요청이 문제가 될 수 있다는 것을 알았다.(Same Origin Policy)

## OOP에 특징에 대해 설명해달라(상속, 캡슐화 등등...)

1. 상속: 하위개념을 확장하는 개념이다. 코드 재활용성이 좋아진다.
2. 추상화: 객체들의 공통된 특성들을 파악하고 불필요한 특성을 제거하여 재활용성을 높힌다.
3. 다형성: 하나의 함수명이나 변수가 상황에 따라 다른의미로 해석될 수 있다. 이를 통해 상속했을 때 기능을 확장하거나 변경할 수 있다.(오버라이딩, 오버로딩)
4. 캡슐화: 로직과 데이터를 하나로 결합한다.

## 객체지향과 함수형프로그래밍를 비교해서 말해보세요

- 순수함수를 통한 사이드 이펙트 제거.
- 순수함수는 불변성을 보장하고 테스트와 유지보수를 수월하게 합니다.

객체지향 프로그래밍은 객체를 만들어서 객체간의 상호작용을 하도록 하는 프로그래밍 페러다임입니다.  
상호작용을 기반으로 하기때문에 각 객체의 상태값을 변경하는 로직이나 객체와 객체간의 의존성이 생깁니다.  
그렇기 때문에 객체지향 프로그래밍은 객체간의 관계를 고려해 설계에 많은 신경을 써야합니다.

반면 함수형 프로그래밍은 순수함수를 기반으로 데이터의 불변성을 보장하기 때문에
코드간의 결합도가 낮고 상대적으로 문맥을 파악하기 쉽습니다.  
같은 입력값에 대하여 같은 반환값을 보장하기 때문에 결과값을 쉽게 예측할 수 있지만 객체지향 프로그래밍은 해당 코트가 실행되는 시점에서 의존성이 있는 변수나 객체에 따라 결과값이 달라지기 때문에 해당 실행시점을 멈춰서 파악해야합니다. 이렇게 함수의 입력값과 무관하게 영향을 끼치는 것을 사이드이펙트라고 부릅니다.

함수형 프로그래밍에서는 사이드 이펙트를 제거하기 위해서 순수함수를 사용합니다.  
순수함수란 입력값이 같을 때 항상 같은 출력값을 반환하는 함수를 말합니다.  
이러한 특성은 테스트를 수월하게 합니다.  
각각의 함수가 외부환경에서 독립적이기 때문에 Mock객체를 사용해서 런타임 환경을 구성해줘야 하는 수고를 줄일 수 있습니다.  
입력값에 대한 출력값만 확인하면 됩니다.  
따라서 유지보수가 쉬워지고 코드를 파악하기 더 쉽습니다. 버그가 줄어들고 코드가 안전해집니다.

- [참고1](https://erokuma.tistory.com/entry/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%84-%EB%B0%B0%EC%9B%8C%EC%95%BC-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0?fbclid=IwAR3t4oJz-3m189cXezhANM0EITfpt5LVLQMgrQp2j0cT4p7zGEZslmGT6_k)

## 프론트엔드에서 관리하는 데이터와 서버에서 관리하는 데이터를 나누는 기준은?

프론트에서 보관할 수 있는 데이터는 보안에 영향이 없고 DB에 저장하지 않는 데이터를 다룬다.  
예를 들면 현재 페이지의 검색조건이나 페이지번호같은 것을 들 수 있다.

SPA에서 글로벌 상태관리를 하는 데이터는 주로 컴포넌트간 상태 전달이 많은 데이터를 다룹니다.  
이 데이터는 그 웹의 찰라, 프레임의 뷰의 상태를 보여주기위한 데이터지 서버에서 보관해야하는 데이터와는 차이가 있습니다.

---

# React

## css in js를 sass의 장점과 비교해서 말해달라

## REDUX의 내부 동작원리를 설명해봐라

- 구독

## FLUX와 REDUX의 구현의 차이를 알고 있나? 비교했을 때 Redux가 가지는 이점은?

## MVC패턴의 문제를 경험해본 적있나?

## 리액트에서 함수형 컴포넌트관련 기능이 주목받는 이유가 뭐라고 생각하나?

## REST API의 문제가 뭐라고 생각하나?

## HOC의 문제점에 대해 설명해달라

## redux-thunk 대신 redux-saga를 사용한 사례와 이유를 말해달라

## spa에서 메모리를 관리하기 위해선 어떻게 해야할까?

## Mixin패턴의 문제가 뭐라고 생각하나

## 옵저버 패턴을 구현해본 적 있나?

## SRR 구현 경험 && next.js

## usecallback 쓰는 이유

## hooks는 어떤걸 써봤는지

## 함수형으로 작성하는지 클래스형으로 작성하는지

## 함수형에서 할 수 없는 작업이 있다면???

## 텔플릿 엔진 언어?를 사용해 봤는지?

## saga를 쓴 이유가 있다면?

## eslint를 사용하는지 어떻게 설정하는지?

## Redux의 구동원리를 설명할 수 있는지?

## SASS를 써본적 있는지?

## webpack보일러 플레이트를 작성해본적 있는지?

## CSS 프레임워크

- matalial UI (구글) 많이 쓴다고 함

## lodash는 사용하는지?

- null check같은 부분 사용하면 편리

## form check 라이브러리를 사용해봤는지 (입력값 검증)

## 함수형 컴포넌트와 클레스형 컴포넌트의 성능차이가 있는지?

## Hooks가 왜 등장했다고 생각하나?

1. 코드 재활용

## 커스텀 훅을 만들어본적이 있는지?

## usecallback은 왜 사용하는지?

## 컴포넌트 분할은 어떻게 하는가?

1. 재사용성
2. 리랜더링 방지

## 싱글톤 패턴 대신에 Redux를 사용하는 이점이 뭐냐?

- 단방향 데이터 흐름.
- FLUX

## 아토믹 디자인이란?

## 리액트에 대해서 설명해보세요

리액트는 가상돔을 이용해서 인터렉티브한 웹을 만들기 위한 자바스크립트 라이브러리입니다.

## CSS in JS를 써본적이 있나 CSS in JS란?

자바스크립트 파일 안에 css를 작성하는 방법을 말합니다.  
css in js 라이브러리는 react에서 styled 컴포넌트를 사용해봤습니다.  
SPA 프레임워크를 이용한 웹은 페이지 단위가 아닌 컴포넌트 단위로 작성됩니다.  
그렇기 때문에 component안에 스타일을 내장하는 방식이 적절할 수 있다고 생각합니다.  
더불어 대다수의 css is js은 class를 사용할 때 고민해야하는 전역 네임스페이스에 대한 고민을 덜어줍니다.

- 조건부 스타일링이 쉬워진다.
- 클래스 네임 중복을 피할수 있습니다.

## 리액트에서 key 프로퍼티를 넣는 이유가 뭔가요?

리액트는 리 렌더링을 여부를 결정하기위해서 형제요소의 key프로퍼티를 기준으로 state를 매핑하고 해당 엘리먼트의 변경여부를 비교합니다.  
그렇기때문에 엘리먼트의 식별키를 key 프로로퍼티로 전달하면 불필요한 렌더링을 막을 수 있고 state가 잘못 매핑되는것을 방지할 수 있습니다.

## PureComponent에 대해서 설명해보세요

Pure Component는 내부적으로 이전 상태값과 현재 상태값을 비교해서 리 렌더링여부를 결정합니다.  
그렇기 때문에 불필요한 재조정을 피할 수 있습니다.  
그렇지만 상태값을 비교할 때 얕은 비교를 하기 때문에 PurCompoent를 상속받은 컴포넌트에 전달하는 props는 불변성을 지켜야 올바른 비교를 할 수 있습니다.

## 가상돔에 대해서 설명해보세요

가상돔은 사용자 인터렉션이 활발하여 리페인트, 리플로 과정이 빈번하게 일어나는 애플리케이션에서 랜더링 최적화를 위해 리액트나 뷰같은 spa 프레임워크에서 도입한 개념이다.  
개발자는 직접 Dom을 수정하는 대신에 가상돔을 수정합니다.  
리액트는 가상돔의 변화가 종합된 최종 상태를 실제 DOM에 한번에 반영하여 리플로와 리페인트를 최소화해서 렌더링 횟수를 줄인다.

## 왜 상태관리 라이브러리가 필요하다고 생각하나?

1. 컴포넌트 디커플링

- 컴포넌트간 결합도를 낮출 수 있습니다.

2. 사이드 이펙트 제거

- 컴포넌트에서 사이드이펙트를 제거할 수 있습니다.
- 컴포넌트에서 직접 데이터 요청을 하지않고 상태관리 도구에서 도맡아한다. 컴포넌트는 뷰만 관리하게 된다.

3. 관심분리

- 비지니스 로직제거, 사이드 이펙트 제거등 관심분리를 통해 코드 가독성이 좋아집니다.
- 단일 책임

4. 컴퓨넌트간 상태값 전달 비용이 클 경우

## 어떤 미들웨어를 사용해 봤나?

1. Redux 라이브러리

- redux-thunk, react-log, redux-saga등이 있습니다.

## redux-saga의 이점이 뭐라고 생각하나?

saga를 쉽게 표현하면 redux action에 대한 이벤트 리스너라고 할 수 있다.
액션을 모니터링하면서 특정 코드를 실행시키거나 다른 액션을 디스패치 하는 식의 동작을 가능하게 한다.

1. 관심분리
   redux를 순수함수 상태로 돌려줍니다.  
   thunk를 사용했을 때와 비교하면 컴포넌트와 액션 크리에이터는 순수함수로 돌아가고 컴포넌트에서는 액션생성자함수를 일괄적으로 사용할 수 있기 때문에 단순해집니다.

2. 요청취소 가능

- 리액트 어플리케이션에서 사이드 이펙트를 통합관리하며 요청을 취소할 수 있다는 이점도 가지고 있습니다.
- 재요청도 가능.

3. 코드 재사용성 향상

4. 통신 처리상태를 처리하는데 용이하다.

- 로딩 스피너 (프로세스 바.)

### 리액트 훅에 대해 설명해보시오 + 이점

함수형 프로그래밍 지향에 따라 함수형 컴포넌트로 클래스 컴포넌트를 대체하기 위한 목적으로 도입되었다.
함수형 컴포넌트에서 상태값 관리나 라이프 사이클 메서드를 사용하게 해주는 기능을 제공한다.  
[참고](https://reactjs.org/docs/hooks-faq.html#how-do-lifecycle-methods-correspond-to-hooks)

**이점**

1. 재사용성  
   기존 라이프 사이클 메서드에 중복으로 사용하는 로직이 생겼는데 hook적용으로 로직 재사용이 가능해졌음
2. 가독성이 좋다  
   기존 라이프사이클 메소드에 비해 가독성이 좋다.
3. 정접 타입을 적용하기 수월하다

4. 가독성이 좋다.  
   useEffect를 사용하면 컴포넌트 라이프사이클에서 생기는 중복코드를 막을 수 있고 (componentDidMount, componentDidUpdate)
   hooks에서는 컴포넌트의 사이드 이펙트를 유발시키는 데이터를 모니터링하는 식으로 코드를 작성할 수 있다.  
   즉, 컴포넌트의 사이드 이펙트 관리라는 접근방식으로 코드를 쓰게 된다.  
   반면 클레스형 컴포넌트는 작업을 언제 수행할까에 포커스를 맞추는 반면
   useEffectr는 뭘 처리할까에 집중합니다.(로직의 행위에 집중한다. )

5. 불필요한 코드를 제거 할 수다.  
   클래스형 컴포넌트는 라이프사이클을 통해 시점 중심으로 사고한다.  
   그렇기 때문에 컴포넌트의 변경사항이 생겼을때 componentDidMount 메서드를 통해서 이전값과 현재값을 직접 비교해야한다.  
   하지만 useEffect를 사용하면 모니터링 하고 있는 변수의 변경이 생겼을 때만 실행하기 때문에 불필요한 로직이 실행되지 않는다.

---

# 자바스크립트(javascript)

## promise.all을 이용해 비동기 처리를 병렬로 실행할 때 중간에 실패한 작업이 있을 때 나머지 작업을 온전히 수행하기 위한 방법이 있다면?

## promise.race에 대한 설명과 적용 사례를 설명해달라.

## 비동기 코드 병렬처리를 어떻게 하는가?

- promise.all

## 프로토타입 기반 생성자 함수 대신 class 문법을 사용하는 취지가 있을지?

- class 키워드를 사용하는 것이 prototype 기반으로 상속을 구현한 코드보다 더 친숙하지 않나?

## 프로토타입 상속을 설명하세요

javascript 객체는 `__proto__`속성을 가지고 있습니다.  
객체의 프로퍼티에 접근할때 해당 프로퍼티가 없으면 `__proto__` 속성을 통해서 참조중인 객체를 탐색합니다.
이 탐색 과정을 prototype chaine이라고 합니다.  
프로토 타입 상속은 `__proto__`속성으로 상위 객체의 속성과 메서드를 참조하는 것을 말합니다.

## Class 는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가

- prototype기반의 생성자 함수의 문법설탕으로 볼 수 있으나 몇가지 차이점이 있다.
- 예를들어 ES6에서는 메서드와 일반함수를 구분한다. 메서드를 new 연산자와 함께 사용할 수 없다.

**ES5와 차이점**

- constructor를 함수로 실행 안됨
- method를 생성자 함수로 실행 안됨
- TDZ 대상.

|             **기능**             |   **ES5**    | **ES6** |
| :------------------------------: | :----------: | :-----: |
|    constructor를 함수로 실행     |      O       |    X    |
|  spuerClass의 constructor 호출   | X(유사 연출) |    O    |
|           method 상속            |      O       |    O    |
|   methods를 생성자함수로 싱행    |      O       |    X    |
|       static methods:상속        |      O       |    X    |
| stric method를 생성자함수로 실행 |      O       |    X    |
|  methods:superClass의메소드호출  | X(유사 연출) |    O    |
|             hoisting             |      O       |    O    |
|               TDZ                |      X       |    O    |

## 타입스크립트(타입스크립트)를 사용해본 경험이 있는가, 타입스크립트에 대한 본인의 생각과 도입시의 장점을 말해달라

**자바스크립트 대비 장점**

1. 정적 타입 체크를 통한 코드 안정화
2. 향상된 문법 사용가능

타입스크립트를 사용하면 확실히 런타임 오류를 미리 발견할 수 있다.  
잘못된 변수타입을 할당해서 생기는 문제라던가 변수가 누락되는것을 사전에 찾아낸다.

타입스크립트를 좋아하는 개발자로서 도입의 이점에 대해서 충분히 공감한다.  
하지만 처음에 타입스크립트를 도입하며 겪어야하는 시행착오(서트파티 라이브러리에서 타입적용이 오히려 번거로워지는 부분)를 고려하면
생산성을 위해 도입을 미루거나 포기할 수도 있다고 생각한다.  
하지만 장기적 관리 관점에서는 적극 찬성.

## 이벤트 위임에 대해 설명하세요

이벤트 위임은 이벤트 리스터를 자식 요소에 추가하는 대신 부모요소에 추가하는 기법입니다.  
리스너는 이벤트 버블링으로 인해 자식요소에서 이벤트가 발생될 때마다 실행됩니다.

- 각 자식 요소에 이벤트 핸들러를 바인딩하지 않고 부모요소 하나에 핸들러를 등록해서 메모리를 절약한다
- 제거된 요소에서 핸들러를 해제하거나 새 요소에 이벤트를 바인딩할 필요가 없다.

## this에 대해 설명하세요

1. 함수: 전역객체를 참조합니다.
2. apply, call, bind: 인수로 전달된 객체를 참조합니다.
3. 메서드: 메서드를 호출한 객체를 참조합니다.
4. 전역공간: 전역객체를 참조합니다.
5. strict mode: 이때는 전역공간에서 undefined가 됩니다.
6. 생성자 함수: 새롭게 생성한 인스턴스를 참조합니다.
7. 화살표 함수: 상위 스코프의 this를 참조합니다.

## AMD vs CommonJS에 대해 어떻게 생각하나요?

CommonJS (require)

- 동기식
- 서버사이드 개발을 염두하고 설계
- 클라이언트 사이드와 서버사이드 JavaScript 개발 사이를 전환할 때 문맥 전환 오버 헤드가 적습니다.

AMD(Asynchronous Module Definition)

- 비동기식
- 모듈의 비동기 로딩을 지원하므로 브라우저용으로 더 많이 사용됩니다.

## 다음이 IIFE로 작동하지 않는 이유를 설명하세요: function foo(){ }();를 IIFE로 만들기 위해서는 무엇을 바꿔야하나요?

이것을 설명하기 위해선 식과 문을 구분해야합니다.  
우선 `function foo(){ }`는 함수 선언문이고 뒤에 오는 괄호`()`는 함수식을 호출할때 사용합니다.  
호출 연산자는 함수식과 함께 사용하기 때문에 함수 선언문을 함수식으로 만들어야합니다.  
이 함수 선언문을 ()로 묶으면 함수 식이 되고 `(function foo(){ })`, 이렇게 하면 다음 ()로 함수를 실행할 수 있습니다.  
이런 함수는 함수가 실행된 후 바로 소멸해버립니다.

```js
(function foo() {
  console.log("test");
})();
foo();

//test
//Uncaught ReferenceError: foo is not defined
```

## 2. var, let/const 차이

1. var

- var는 변수를 해당 실행스코프에 등록합니다. (함수스코프)
- 재할당이 가능합니다.
- 재선언이 가능하다.
- TDZ이 발생하지 않습니다.

2. let

- 변수를 블록스코프에 등록합니다.
- 재선언이 불가능하다.
- 재할당이 가능합니다.
- TDZ이 발생합니다.

3. const

- 변수를 블록스코프에 등록합니다.
- 재선언이 불가능하다.
- 재할당이 불가능합니다.
- TDZ이 발생합니다.

## RESTful API에 대한 이해와 사용경험에 대해 말해달라.

Rest API는 API를 효율적으로 이용하기 위한 아키텍쳐를 말합니다.  
모든 자원에 주소를 부여하여 API를 통해 접근이 가능하며 세션같은 상태값이 없기때문에 디바이스에 대한 종속성이 없는것이 특징입니다.

사용경험으로 어플에 이용중인 API를 모바일 웹에서 사용하는 프로젝트를 한적이 있습니다.  
사용에 큰 무리는 없었지만 프론트 환경이 달랐기때문에 Overfecing, underfetching, N+1쿼리등의 문제가 있었습니다.

- REpresentational State Transfer
- RESTAPI는 API를 효율적으로 사용하기 위해 고안된 아키텍쳐다.
- 웹에 존재하는 모든자원(이미지, 동영상, DB자원)을 정의하고 자원에 대한 주소를 지정하는 방법론
- REST API는 멀티 디바이스 지원에서 범용적 사용이 가능하다.
- 특정 언어나 기술에 종속받지 않는다.(HTTP를 요청하는 모든 플랫폼에서 요청이 가능하다.)
- 캐싱을 이용하여 대량의 요청을 효율적으로 처리할 수 있다.
- 클라이언트와 결합도가 낮음 API를 재활용가능.
- URI만 보고 대략 기능을 유추할 수 있다.(자체 표현)
- 계층구조를 통해 proxy, gateway등을 사용할 수 있다.(보안, 로드벨런싱, 암호화.)

## null, undefined, undeclared의 차이점은 무엇인가요?

1. null  
   변수에 null이란 값을 할당했습니다. 명시적으로 아무것도 없음을 나타냅니다.

2. undefined

- 선언되었지만, 값이 할당되지 않은 변수입니다.
- undefined 타입입니다

3. undeclared  
   선언되지 않은 별수에 값을 할당할때 생성됩니다.  
   strict모드에서는 이런 경우 참조 오류(ReferenceError)가 납니다.

```js
function foo() {
  x = 1; // strict 모드에서 ReferenceError를 발생시킵니다.
}

foo();
console.log(x); // 1
```

## 클로저란?

중첩함수 구조에서 내부함수가 참조하고 있는 렉시컬 스코프를 클로저를 의미합니다.  
내부함수를 반환하게 됐을때 외부함수의 스코프에 접근할 수 있고 외부함수를 즉시실행함수로 선언하게 될 경우
외부함수의 실행컨텍스트는 내부함수의 렉시컬 스코프를 통해서만 접근가능하여 밀실화를 할 수 있습니다.

- 밀실화
- 모듈화

## .forEach 루프와 .map() 루프 사이의 주요 차이점을 설명할 수 있나요?

가장 큰 차이점은 반환값의 유무입니다.  
map은 배열 인덱스를 인수로 콜백을 실행하여 새로운 값을 반환합니다.  
배열에 새로운 값을 매핑하는 것입니다.  
이에 반해 forEach는 값을 반환하지 않으므로 단순 반복만 사용할때 사용하면 됩니다.

## 익명함수의 사용례를 설명해달라.

익명함수는 개발자에 의해 직접 호출될 필요가 없는 곳에 사용한다.

1. 즉시실행함수

```js
(function () {
  // 코드
})();
```

2. 콜백

```js
setTimeout(function () {
  console.log("Hello world!");
}, 1000);
```

## 호스트 객체와 내장객체의 차이가 무엇인가?

내장 객체는 ECMAScript 사양에 정의된 JavaScript 언어의 일부인 객체입니다. (예: String, Math, RegExp, Object, Function 등)
호스트 객체는 window, XMLHTTPRequest 등과 같이 런타임 환경 (브라우저 or 노드)에 의해 제공됩니다.

## function Person(){}, var person = Person(), var person = new Person()의 차이점은 무엇인가요?

1. `function Person(){}`  
   함수 선언

2. `var person = Person()`
   함수 호출

3. `var person = new Person()`  
   함수를 생성자 함수로 호출, 프로토타입 체인에 의한 상속을 받는다.

## .call과 .apply의 차이점은 무엇인가요?

매개변수의 차이가 있습니다.  
call은 복수의 인자를 받고 apply는 배열을 두번자 인자로 받습니다.

```js
function add(a, b) {
  return a + b;
}

console.log(add.call(null, 1, 2)); // 3
console.log(add.apply(null, [1, 2])); // 3
```

## Function.prototype.bind란?

전달받은 객체를 this로 바인딩하여 새로운 함수를 반환합니다. 내부적으로 this를 래핑하는 함수가 구현되어 있습니다.

## Ajax에 대해 가능한 한 자세히 설명하세요.

자바스크립트를 이용해 비동기로 리소스를 요청하는 웹 기술을 말합니다.  
Ajax를 사용하면 비동기로 데이터를 요청하기 때문에 동기식 데이터 요청시 화면 깜빡임문제가 사라지고
자연스러운 동작이 가능하여 사용자 경험이 좋아집니다.  
코드적으로는 프리젠테이션 레이어와 데이터레이어를 분리할 수 있어 유지보수에 좋습니다.

## AJax의 장단점.

**장점**

1. 사용자 경험 향상
   - 화면 리프레시가 생기지 않기때문에 보다 자연스러운 서비스 제공가능
2. 통신비용 절감
   - 전체 페이지가 아닌 필요한 데이터만 요청하기 때문에 통신비용이 줄어든다
3. 웹페이지의 상태관리 가능
   - 페이지 리로드가 되지 않기때문에 상태를 관리가 가능하다.

**단점**

1. 검색엔진 최적화에 어려움이 생김
   - 로드되지 않은 콘텐츠가 존재하기 때문
2. 북마크가 어려움
   - 페이지 단위가 아니라 웹페이지의 상태를 통해 컨텐츠가 바뀌기 때문에 북마크가 어려울 수 있음.

## 호이스팅이란?

호이스팅은 블록 내에서 선언된 변수들을 스코프의 상단으로 옮기는 것을 말한다. 이런 특성때문에
`var` 키워드나 함수 선언문으로 생성한 함수는 생성 시점보다 윗부분에서 접근이 가능합니다.

## javascript의 내장객체를 확장하는 것의 문제점은 무엇일까요?

서드파티 라이브러리와 충돌가능성이 있습니다. 범용적으로 사용되는 내장객체를 수정하는 패턴은 코드의 안정성을 보장할 수 없습니다.  
내장객체를 확장하는 대신에 폴리필을 만드는 것이 낫습니다.

## window.load와 document.DOMContentLoaded의 차이는?

1. window.load
   - DOM과 모든 종속 리소스가 로드된 후 트리거 됩니다.
2. DOMContentLoaded
   - 리로스 로딩을 기다리지 않고 초기 HTML문서가 로드되고 파싱되면 트리거 됩니다.

## Javascript관련하여 Same Origin Policy 을 설명하세요

same-origin은 브라우저에서 자바스크립트를 통해서 외부 도메인에 자료를 요청하는것을 막는것을 말합니다.  
이를 해결하기위해서 CORS를 준수해야합니다.

## strict Mode에 대해서 설명해보세요

자바스립트는 흔히 유연한 언어라고 하는데 이런 유연함이 큰 어플리케이션을 구축할 때 사이드이펙트가 될 수 있습니다.  
엄격 모드는 이런 자바스립트의 유연함을 엄격하게 제안함으로써 일관된 코징 보장하도록 하는 명령문입니다.  
간단한 예로 `var`키워들을 붙이지 않고 선언할 경우에 전역변수가 되는데 엄격 모드에서는 에러가 납니다.  
가능한 엄격모드를 사용하는 것을 권장하지만 외부 코드와 충돌할 수 있는 문제가 있습니다.  
엄격모드를 사용하기 위해서는 해당 코드와 의존성이 있는 코드와의 충돌을 고려해야합니다.

**장점**

- 실수로 전역변수를 만드는것이 불가능하다.
- 암묵적으로 실패한 예외를 throw하지 못하는 할당을 만든다.
- 함수의 매개변수 이름을 유일값이 되도록 제한한다.
- this는 전역컨텍스트에서 undefined이다.

**단점**

- 코드병합에 문제가 있을 수 있다. (엄격모드로 작성하지 않은 코드)
- function.caller와 function.arguments에 접근할 수 없다.

## single page app과 SEO를 지원하게 만드는 방법에 대해서 설명해보세요

요즘엔 웹 사이트가 아닌 웹 앱을 제작하는 경우가 많습니다.  
웹앱은 동적이고 사용자 인터렉션이 잦은 웹을 말합니다. 이런 웹앱을 전통적인 방식으로 서버에서 HTML을 받아서 렌더링하면
새로고침으로 인한 플래시 현상, 리소스 요청이 불필요하게 늘어나는 등의 문제때문에 사용자 경험이 떨어지빈다.(서버 사이드 렌더링)

이런 이유로 등장한것이 SPA입니다. SPA에서는 클라이언트 사이드 렌더링을 합니다.  
브라우저는 애플리케이션에 필요한 스크립트 및 스타일시트를 초기 로딩 시점에 로드합니다.  
SPA는 초기 로딩때 마운트된 javascript를 통해서 페이지를 동적으로 업데이트합니다.

**장점**

- 새로고침시 발생하는 플래쉬 현상이 나타나지 않습니다.
- 서버에 대한 HTTP요청이 줄어듭니다.
- 일반적으로 SPA구조에서는 서버사이드와 독립적으로 구현되어 있어 서버코드를 다양한 플랫폼에서 사용하기 수월합니다.

**단점**

- 검색엔진 최적화가 어렵습니다.
  - 서버사이드 렌더링을 지원해야한다.
- 초기로딩에 시간이 많이 걸립니다.

## 프로미스의 장단점

1. 콜백지옥을 해결합니다.
2. 프로미스 체인은 가독성이 좀더 좋고 연속적인 비동기 코드 작성이 수워합니다.
3. 병렬 비동기 코드를 작성할 수 있습니다. (promise.all)
4. 예외처리가 수월합니다.

**단점**

- 구형브라우저 지원을 위해 폴리필이 필요합니다.

## "attribute"와 "property"의 차이점은 무엇인가요?

attribute는 HTML마크업에서 정의하며 property는 HTML을 파싱한 DOM에 정의됩니다.

## Promise에 대해서 설명하고 예시를 들어봐라

콜백 패턴의 문제를 보완할 수 있는 비동기 처리 패턴입니다.  
콜백패턴에는 콜백헬, 에러처리의 한계 등의 문제가 있습니다. 프로미스를 이용하면 이 단점을 해결할 수 있습니다.

```js
const promise1 = function (param) {
  return new Promise(function (resolve, reject) {
    if (param) {
      resolve("합격");
    } else {
      reject("불합격");
    }
  });
};
//프로미스 실행
promise1(true).then(
  function (result) {
    console.log(result); // 합격
  },
  function (err) {
    console.log(err); // 불합격
  }
);
```

콜백은 에러처리의 단점이 있습니다.

```js
try {
  setTimeout(() => {
    throw "Error!";
  }, 1000);
} catch (e) {
  console.log("에러 캐치 불가능...");
  console.log(e);
}
```

promise에서는 이 단점을 보완합니다.

```js
//프로미스 생성
const promise1 = (param) =>
  new Promise(function (resolve, reject) {
    if (param) {
      resolve("합격");
    } else {
      reject("불합격");
    }
  });

promise1(null)
  .then(console.log)
  .catch((e) => {
    console.log(e);
  });
```

## DOM이란?

Document Object Model의 약자.  
브라우저는 HTML문서를 파싱해서 DOM객체를 만든다.  
개발자는 DOM을 통해서 문서를 동적으로 조작할 수 있다.

## 실행컨텍스트란?

자바스크립트 코드가 실행하기 위한 환경을 의미한다.  
함수가 실행될 때 마다 실행컨텍스트가 생성되는데 여기에는 생성당시 스코프, 매개변수, 내부변수 등의 정보가 담겨있습니다.  
함수 내부에서 사용되는 변수는 먼저 해당 함수의 실행컨스트를 탐색하고 값을 찾지 못하면 스코프체인에 의해 상위 실행컨텍스트를 탐색합니다.  
최종적으로 함수 실행이 마무리 되면 해당 컨텍스트가 사라진다.

## 이벤트 루프에 대해서 설명, 동시성 모델에 대해서 설명하라

싱글스레드 언어인 자바스크립트가 동시성을 제공하기 위해서는 비동기 함수를 사용한다.  
그럼 비동기로 처리된 함수의 콜백함수가 실행될 타이밍을 제어할 필요가 있는데 그 일을 하는 것이 이벤트 루프이다.  
이벤트 루프는 호출스택을 모니터링하면서 호출스택이 비었을 때(전역 컨텍스트가 사라졌을 때) 콜백함수가 쌓여있는 task queqe에서 콜백함수를 호출스택으로 밀어넣는다

## 화살표함수를 언제 사용하나요?

- 현재 실행컨텍스트의 this를 유지하고 싶을 때 사용하면 유용합니다.
- 제한적으로 콜백함수에 화살표 함수를 사용하면 축약문법의 이점을 누릴 수 있다.

## 생성자의 메서드에 화살표 함수를 사용했을때의 이점

- 함수 생성시 this의 값이 설정되고 그 이후에는 변경할 수 없다는 것입니다.

```js
const Person = function (firstName) {
  this.firstName = firstName;
  this.sayName1 = function () {
    console.log(this.firstName);
  };
  this.sayName2 = () => {
    console.log(this.firstName);
  };
};

const john = new Person("John");
const dave = new Person("Dave");

john.sayName1(); // John
john.sayName2(); // John

// 일반 함수의 'this'값은 변경할 수 있지만, 화살표 함수는 변경할 수 없습니다.
john.sayName1.call(dave); // Dave (because "this" is now the dave object)
john.sayName2.call(dave); // John

john.sayName1.apply(dave); // Dave (because 'this' is now the dave object)
john.sayName2.apply(dave); // John

john.sayName1.bind(dave)(); // Dave (because 'this' is now the dave object)
john.sayName2.bind(dave)(); // John

var sayNameFromWindow1 = john.sayName1;
sayNameFromWindow1(); // undefined (because 'this' is now the window object)

var sayNameFromWindow2 = john.sayName2;
sayNameFromWindow2(); // John
```

## 고차함수란??

함수를 인자로 받는 함수를 말합니다.  
이렇게 함으로써 반복되는 연산을 추상화할 수 있다. map, filter, reduce등이 고차함수의 예이다.

## curry함수란? 어떤 이점이 있는지?

둘 이상의 매개 변수가 있는 함수가 여러 함수로 분되는 패턴입니다.  
이 방식은 각각의 매개변수가 기록된 함수를 반환함으로써 함수 재사용성을 높혀줍니다.

각 인자를 하나씩 저장해서 중간 단계의 함수를 재활용할 수 있습니다.

```js
function curry(fn) {
  if (fn.length === 0) {
    return fn;
  }

  function _curried(depth, args) {
    return function (newArgument) {
      if (depth - 1 === 0) {
        return fn(...args, newArgument);
      }
      return _curried(depth - 1, [...args, newArgument]);
    };
  }

  return _curried(fn.length, []);
}

function add(a, b) {
  return a + b;
}

var curriedAdd = curry(add);
var addFive = curriedAdd(5);

var result = [0, 1, 2, 3, 4, 5].map(addFive); // [5, 6, 7, 8, 9, 10]
```

## spread 문법을 사용할 때의 이점은 무엇이며 rest 문법과 다른 점은 무엇인가요?

spread문법은 불변성을 지키기 위해서 새로운 객체를 반환할 때 유용하게 사용할 수 있습니다.  
객체나 배열을 spread문법을 이용해 손쉽게 복사할 수 있습니다.

```js
var ted = {
  name: "Tad",
  age: 29,
};

var cloneTad = { ...ted };
```

2. rest문법은 나열되는 값들중 일부만 명시적으로 사용하는 경우 유용하다.

- 비구조화 할당을 할 때 모든인자를 변수에 대입하지 않고 그룹화할 때 유용하다.

```js
const [a, b, ...rest] = [1, 2, 3, 4];
// a: 1, b: 2, rest: [3, 4]

const { e, f, ...others } = {
  e: 1,
  f: 2,
  g: 3,
  h: 4,
};
// e: 1, f: 2, others: { g: 3, h: 4 }
```

## static Member를 만드는 이유가 무엇인가요?

- 메모리 재활용
  static 멤버는 클래스의 특정 인스턴스와 독립적이며 항상 선언 당시의 값을 유지합니다.  
  이는 인스턴스간 공통된 속성과 메서드를 선언했을 때 메모리를 재사용하는 효과가 있습니다.

## 비구조화 할당은 무엇인지? 예를 들어보세요

객체나 배열의 요소를 간단하게 변수에 할당하는 방법을 말합니다.  
이 기능을 통해 코드를 간결하게 만들 수 있습니다.

```js
const ted = {
  name: "ted",
  age: 29,
};

const { name, age } = ted;
console.log(name, age);
```

## 스코프 체인에 대해서 설명해 달라

- 함수에서 변수를 탐색하는 방법을 말한다. 함수가 가지고 있는 scope 프로퍼티를 기반으로 상위 스코프로 이동하면서 변수를 탐색한다.
- 이 Scope변수에는 부모함수의 렉시컬 스코프가 참조되어 있습니다.
- 쉽게 말해 변수를 탐색할 때 지역변수에 없으면 상위 스코프의 지역변수를 탐색하는 것을 말합니다. 최종적으로 전역변수(글로벌 변수)를 탐색합니다.

## 콜백함수에 대해 설명하라

어떤 함수의 실행이 종료된 뒤 에 실행하는 함수를 말한다.  
콜백함수는 비동기를 통해 동시성을 제공하는 자바스크립트에서 비동기적 로직을 연속적으로 사용하거나 후속처리를 하기 위해 필수적이다.

## async awaite에 대해서 설명해 달라.

1. async

- 함수 선언시 사용되는 키워드이며 해당 함수가 비동기 함수임을 나타내고 반환값으로 프로미스를 반환합니다.
- awaite키워드는 async함수에서 동작합니다.

```js
async function foo() {
  return "test";
}

foo().then(console.log);
```

2. awiat

- 이 키워드는 프로미스를 suspend하는 키워드로 비동기로직을 동기적으로 동작하게 만들어 줍니다.
- 이 키워드는 async함수 내부에서만 사용할 수 있습니다.
- 이 키워드를 사용하면 promise의 resolve메서드의 인자가 반환값으로 반환됩니다.

```js
async function foo() {
  const re = await new Promise((resolve, reject) => {
    setTimeout(resolve, 1000, "done!!");
  });
  console.log(re);
  console.log("done after");
}

foo();
```

---

# Webpack

## transfile과 pollifill의 차이는?

1. pollifill

- 구형 브라우져에서 지원하지 않은 문법을 사용하고 싶을 때 pollifill을 이용하여 호환성을 맞출 수 있다.
- 비호환 엔진에 없는 코드의 기능을 지원하기 위해서 삽입하는 코드 조각
  - bluebird 라이브러리에서 promise
  - 모든 기능에 폴리필을 쓸수 없다.

2. Transpiler(트랜스파일러)

- 최신버전 소스를 구버전 소스로 변환하는것.
- 최신 문법을 이전 버전으로 변환하여 주는것을 의미한다. (마이그레이션?)

## 번들링툴의 보일러플레이트를 직접 작성해 봤는가?

## 코드 스플리팅을 해봤는가?

## AWS같은 클라우드 서비스를 이용해봤나?

## REF

- [프론트엔드 면접 핸드북](https://github.com/yangshun/front-end-interview-handbook/blob/master/contents/kr/javascript-questions.md)
- [면접후기](https://velog.io/@denny6389/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B8%B0%EC%88%A0-%EB%AC%B8%EC%A0%9C)
